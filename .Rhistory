s <- svd(Z[gSetIdx, ])
s$v[, 1]
}
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, nrow(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(Z, gSetIdx)
block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
Z <- t(DelayedArray::scale(t(X)))
Z <- as(Z, "HDF5Array")
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
geneSets <- list("my_list1"=c(1,2), "mylist2"=c(3,4))
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
names(geneSets)
length(names(geneSets))
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, nrow(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
Z <- t(DelayedArray::scale(t(X)))
Z <- as(Z, "HDF5Array")
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
es
es <- do.call(rbind, es)
es
es <- as(es, "HDF5Array")
es
geneSets
es2 <- es
Z <- t(scale(t(X)))
es <- bplapply(geneSets, rightsingularsvdvectorgset, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
es
es2
library(scRNAseq)
sce <- ReprocessedAllenData("tophat_counts")
library(scRNAseq)
x <- do.call(cbind, lapply(1:20, function(j) {
rpois(n = 10000, lambda = sample(20:40, 10000, replace = TRUE))
}))
colnames(x) <- paste0("S", 1:20)
x <- realize(x, "HDF5Array")
x
geneSets <- list("my_list1"=1:500,
"my_list2"=1001:1500)
geneSets
X <- x
X
plage2 <- function(X, geneSets, parallel.sz, verbose=TRUE,
BPPARAM=SerialParam(progressbar=verbose)) {
Z <- t(DelayedArray::scale(t(X)))
Z <- as(Z, "HDF5Array")
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
es <- as(es, "HDF5Array")
es
}
res1 <- plage(x, geneSets)
plage <- function(X, geneSets, parallel.sz, verbose=TRUE,
BPPARAM=SerialParam(progressbar=verbose)) {
Z <- t(scale(t(X)))
es <- bplapply(geneSets, rightsingularsvdvectorgset, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
if (length(geneSets) == 1)
es <- matrix(es, nrow=1)
rownames(es) <- names(geneSets)
colnames(es) <- colnames(X)
es
}
res1 <- plage(x, geneSets)
res1
res2 <- plage2(x, geneSets)
res2
library(bench)
bench::mark(
plage1(x, geneSets),
plage2(x, geneSets),
)
bench::mark(
plage(x, geneSets),
plage2(x, geneSets),
check=FALSE
)
print(object.size(res), unit="Kb")
print(object.size(res2), unit="Kb")
res
print(object.size(res1), unit="Kb")
print(object.size(res2), unit="Kb")
sce <- readRDS("/home/bort/Downloads/pbmc.sce.rds")
# sce <- readRDS("/home/bort/curro/gsva-devel/shortdgC.sce.rds")
gset.idx.list <- list("my_genes1" = sample(rownames(sce), 5000),
"my_genes2" = sample(rownames(sce), 5000))
se <- sce
annotation <- names(assays(se))[1]
expr <- assays(se)[[annotation]]
.filterFeatures <- function(expr, method) {
if(is(expr, "DelayedArray")){
sdGenes <- DelayedMatrixStats::rowSds(expr)
} else {
sdGenes <- apply(expr, 1, sd)
}
if (any(sdGenes == 0) || any(is.na(sdGenes))) {
warning(sum(sdGenes == 0 | is.na(sdGenes)),
" genes with constant expression values throuhgout the samples.")
if (method != "ssgsea") {
warning("Since argument method!=\"ssgsea\", genes with constant expression values are discarded.")
expr <- expr[sdGenes > 0 & !is.na(sdGenes), ]
}
}
expr
}
expr <- .filterFeatures(expr, method)
expr
expr <- as(expr, "HDF5Array")
expr <- NULL
sce <- NULL
se <- NULL
library(TEN)
library(TENxBrainData)
sce <- TENxBrainData20k()
sce
rownames(sce) <- rowData(sce)$Symbol
colData(sce)
colnames(sce) <- colData(sce)$Sequence
sce
se <- sce
annotation <- names(assays(se))[1]
expr <- assays(se)[[annotation]]
expr
expr <- as(expr, "HDF5Array")
se <- sce
annotation <- names(assays(se))[1]
expr <- assays(se)[[annotation]]
expr
# sce <- readRDS("/home/bort/curro/gsva-devel/shortdgC.sce.rds")
gset.idx.list <- list("my_genes1" = sample(rownames(sce), 5000),
"my_genes2" = sample(rownames(sce), 5000))
gset.idx.list
se <- NULL
sce <- NULL
expr <- .filterFeatures(expr, method)
expr
mapped.gset.idx.list <- gset.idx.list
mapped.gset.idx.list <- lapply(mapped.gset.idx.list,
function(x, y) na.omit(fastmatch::fmatch(x, y)),
rownames(expr))
filterGeneSets <- function(gSets, min.sz=1, max.sz=Inf) {
gSetsLen <- sapply(gSets,length)
return (gSets[gSetsLen >= min.sz & gSetsLen <= max.sz])
}
mapped.gset.idx.list <- filterGeneSets(mapped.gset.idx.list,
min.sz=max(1, min.sz),
max.sz=max.sz)
eSco2 <- plage2(expr, mapped.gset.idx.list , parallel.sz, verbose, BPPARAM=BPPARAM)
X <- expr
Z <- t(DelayedArray::scale(t(X)))
t(X)
dimnames(X)
t(X)
colnames(X)
rownames(X)
t(X)
is.character(dimnames(X))
which(is.character(dimnames(X)))
as.character(dimnames(X))
dinmaes <- as.character(dimnames(X))
dinmaes <- NULL
colnames(X) <- NULL
sce
BiocManager::install("scRNAseq")
options(Ncpus=6)
BiocManager::install("scRNAseq")
sce <- ReprocessedAllenData("tophat_counts")
library(scRNAseq)
sce <- ReprocessedAllenData("tophat_counts")
counts <- assay(sce, "tophat_counts")
counts
str(counts)
print(object.size(counts), unit="Kb")
print(object.size(counts), unit="Mb")
counts <- as(counts, "HDF5Array")
library(HDF5Array)
counts <- as(counts, "HDF5Array")
counts
expr <- as(t(counts), "HDF5Array")
expr
# sce <- readRDS("/home/bort/curro/gsva-devel/shortdgC.sce.rds")
gset.idx.list <- list("my_genes1" = sample(rownames(expr), 100),
"my_genes2" = sample(rownames(expr), 100))
method <- "plage"
kcdf <- "Gaussian"
min.sz <- 1
max.sz <- Inf
abs.ranking <- FALSE
parallel.sz=1L
mx.diff=TRUE
tau=1
kernel=TRUE
ssgsea.norm=TRUE
verbose=TRUE
rnaseq=FALSE
BPPARAM=SerialParam(progressbar=verbose)
library(BiocParallel)
BPPARAM=SerialParam(progressbar=verbose)
.filterFeatures <- function(expr, method) {
if(is(expr, "DelayedArray")){
sdGenes <- DelayedMatrixStats::rowSds(expr)
} else {
sdGenes <- apply(expr, 1, sd)
}
if (any(sdGenes == 0) || any(is.na(sdGenes))) {
warning(sum(sdGenes == 0 | is.na(sdGenes)),
" genes with constant expression values throuhgout the samples.")
if (method != "ssgsea") {
warning("Since argument method!=\"ssgsea\", genes with constant expression values are discarded.")
expr <- expr[sdGenes > 0 & !is.na(sdGenes), ]
}
}
expr
}
expr <- .filterFeatures(expr, method)
expr
mapped.gset.idx.list <- gset.idx.list
mapped.gset.idx.list <- lapply(mapped.gset.idx.list,
function(x, y) na.omit(fastmatch::fmatch(x, y)),
rownames(expr))
filterGeneSets <- function(gSets, min.sz=1, max.sz=Inf) {
gSetsLen <- sapply(gSets,length)
return (gSets[gSetsLen >= min.sz & gSetsLen <= max.sz])
}
mapped.gset.idx.list <- filterGeneSets(mapped.gset.idx.list,
min.sz=max(1, min.sz),
max.sz=max.sz)
rightsingularsvdvectorgset <- function(gSetIdx, Z) {
s <- svd(Z[gSetIdx, ])
s$v[, 1]
}
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, nrow(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
plage2 <- function(X, geneSets, parallel.sz, verbose=TRUE,
BPPARAM=SerialParam(progressbar=verbose)) {
Z <- t(DelayedArray::scale(t(X)))
Z <- as(Z, "HDF5Array")
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
es <- as(es, "HDF5Array")
es
}
plage3 <- function(X, geneSets, parallel.sz, verbose=TRUE,
BPPARAM=SerialParam(progressbar=verbose)) {
Z <- t(DelayedArray::scale(t(X)))
es <- bplapply(geneSets, right2, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
es <- as(es, "HDF5Array")
es
}
plage <- function(X, geneSets, parallel.sz, verbose=TRUE,
BPPARAM=SerialParam(progressbar=verbose)) {
Z <- t(scale(t(X)))
es <- bplapply(geneSets, rightsingularsvdvectorgset, Z,
BPPARAM=BPPARAM)
es <- do.call(rbind, es)
if (length(geneSets) == 1)
es <- matrix(es, nrow=1)
rownames(es) <- names(geneSets)
colnames(es) <- colnames(X)
es
}
library(bench)
bench::mark(
plage(expr, mapped.gset.idx.list),
plage2(expr, mapped.gset.idx.list),
plage3(expr, mapped.gset.idx.list),
check=FALSE
)
bench::mark(
plage(expr, mapped.gset.idx.list),
plage2(expr, mapped.gset.idx.list),
plage3(expr, mapped.gset.idx.list),
check=FALSE
)
plage3(expr, mapped.gset.idx.list)
plage2(expr, mapped.gset.idx.list)
expr
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
sink <- HDF5RealizationSink(dim = c(1L, ncol(expr)))
sink
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
bench::mark(
plage(expr, mapped.gset.idx.list),
plage2(expr, mapped.gset.idx.list),
plage3(expr, mapped.gset.idx.list),
check=FALSE
)
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
right2(mapped.gset.idx.list[[1]], expr)
expr
showtree(expr)
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
# block <- as(matrix(block, 1, nrow(Z)), "HDF5Matrix")
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
right2(mapped.gset.idx.list[[1]], expr)
nrow(expr)
sink <- HDF5RealizationSink(dim = c(1L, nrow(Z)))
sink <- HDF5RealizationSink(dim = c(1L, nrow(expr)))
sink
matrix(block, 1, nrow(Z))
matrix(block, 1, nrow(expr))
Z <- expr
block <- rightsingularsvdvectorgset(gSetIdx, Z)
gSetIdx <- mapped.gset.idx.list[[1]]
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block
dim(block)
length(block)
ncol(Z)
block <- as(matrix(block, 1, length(block)), "HDF5Matrix")
block
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
seq_along(sink_grid)
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
sink_grid <- defaultAutoGrid(sink, block.shape="first-dim-grows-first")
seq_along(sink_grid)
sink <- write_block(sink, sink_grid[[bid]], block)
sink <- write_block(sink, sink_grid[[1]], block)
sink <- write_block(sink, sink_grid[[1L]], block)
sink
close(sink)
res <- as(sink, "DelayedArray")
res
rightsingularsvdvectorgset(mapped.gset.idx.list[[1]], Z)
block <- rightsingularsvdvectorgset(gSetIdx, Z)
sink <- write_block(sink, sink_grid[[bid]], block)
sink <- write_block(sink, sink_grid[[1L]], block)
block <- matrix(block, 1, length(block))
sink <- write_block(sink, sink_grid[[bid]], block)
sink <- write_block(sink, sink_grid[[1L]], block)
close(sink)
res <- as(sink, "DelayedArray")
res
right2 <- function(gSetIdx, Z) {
sink <- HDF5RealizationSink(dim = c(1L, ncol(Z)))
sink_grid <- rowAutoGrid(sink, nrow = 1)
for(bid in seq_along(sink_grid)){
block <- rightsingularsvdvectorgset(gSetIdx, Z)
block <- matrix(block, 1, length(block))
sink <- write_block(sink, sink_grid[[bid]], block)
}
close(sink)
res <- as(sink, "DelayedArray")
res
}
right2(mapped.gset.idx.list[[1]], Z)
bench::mark(
plage(expr, mapped.gset.idx.list),
plage2(expr, mapped.gset.idx.list),
plage3(expr, mapped.gset.idx.list),
check=FALSE
)
expr
expr2 <- as(expr, "matrix")
expr2
str(expr2)
x1 <- DelayedMatrixStats::rowSds(expr)
x2 <- apply(expr, 1, sd)
x1
x2
all.equal(x1, x2)
x1
x2
names(x2)
names(x2) <- NULL
x1
x2
all.equal(x1, x2)
x1 <- DelayedMatrixStats::rowSds(expr2)
x2 <- apply(expr2, 1, sd)
x1
x2
names(x2) <- NULL
all.equal(x1, x2)
setwd("~/curro/gsva-devel/GSVA")
library(TENxBrainData)
library(GSVA)
sce <- TENxBrainData20k()
rownames(sce) <- rowData(sce)$Symbol
rownames(sce)
colData(sce)
colnames(sce) <- colData(sce)$Sequence
colData(sce) <- NULL
rowData(sce) <- NULL
sce@assays
sce@assays$counts
sce@assays$counts
assay(sce, "counts")
print(object.size(assay(sce, "counts")), unit="Mb")
assay(sce, "counts") <- as(assay(sce, "counts"), "HDF5Array" )
print(object.size(assay(sce, "counts")), unit="Mb")
print(object.size(assay(sce, "counts")), unit="Kb")
library(bench)
genes <- list("my_list1"=sample(rownames(sce), 500),
"my_list2"=sample(rownames(sce), 500))
genes
assay(sce, "counts")
res <- gsva(sce, genes)
res <- gsva(sce, genes, method="plage")
X <- assay(sce, "counts")
X
t(X)
DelayedArray::scale(t(X))
Matrix::t(X)
DelayedArray::scale(Matrix::t(X))
colMeans(t(X), na.rm=TRUEç)
colMeans(t(X), na.rm=TRUE)
x <- t(X) - colMeans(t(X), na.rm=TRUE)
x <- t(X) - colMeans(X, na.rm=TRUE)
x
DelayedArray::scale(t(X))
browser()
Z <- t(DelayedArray::scale(t(X)))
X
t(X)
x1 <- t(X)
DelayedArray::scale(x1)
DelayedArray::scale.DelayedMatrix(x1)
library(DelayedMatrixStats)
DelayedArray::scale.DelayedMatrix(x1)
sce <- TENxBrainData20k()
assay(sce, "counts")
X <- assay(sce, "counts")
X
t(X)
DelayedArray::scale(t(X))
DelayedArray::scale(X)
BiocManager::install()
options(Ncpus=6)
BiocManager::install()
library(DelayedArray)
DelayedArray::scale(X)
sce <- readRDS("/home/bort/curro/gsva-devel/shortdgC.sce.rds")
sce
assay(sce, "counts")
assay(sce, "counts") <- as(assay(sce, "counts"), "HDF5Array")
X <- assay(sce, "counts")
X
DelayedArray::scale(X)
library(Matrix)
DelayedArray::scale(X)
